<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:type" content="website"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png"/><link rel="manifest" href="/assets/favicon/site.webmanifest"/><title>How to learn software development - tzyl</title><meta name="robots" content="index,follow"/><meta name="description" content="Practical advice for beginners"/><meta property="og:title" content="How to learn software development - tzyl"/><meta property="og:description" content="Practical advice for beginners"/><meta property="og:image" content="https://tzyl.dev/_next/static/media/how-to-learn-dev@2x.ec89749a.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/vs2015.min.css" integrity="sha256-Pi771++jBrwgeHVYGOa1sjN8idXlrrYSKQVI7+JA54k=" crossorigin="anonymous"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/4ad21499c30e2b78.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/4ad21499c30e2b78.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/8a49eceef60c74a6.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/8a49eceef60c74a6.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-fda0a023b274c574.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-5eadc1f251ff66c8.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-d5c5c666efa9c6b4.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/2-b73848b1def35d0a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/73-b9dc35ca547b1bd7.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/249-f6aeeac4de64f95f.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-90750821cb9c8d0a.js" defer="" crossorigin=""></script><script src="/_next/static/z-bIchNx-oJygQTEe6m7g/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/z-bIchNx-oJygQTEe6m7g/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="mx-auto flex min-h-screen max-w-screen-lg flex-col px-5 text-gray-800"><nav class="flex flex-wrap items-center pt-8 pb-8"><div class="flex items-center"><a class="mr-2 font-bold" href="/">tzyl</a><a href="https://github.com/tzyl" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="mx-1 hover:text-green-300 transition-all duration-100" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://www.linkedin.com/in/timothyleung95" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="mx-1 hover:text-green-300 transition-all duration-100" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg></a><a href="mailto:me@tzyl.dev" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="mx-1 hover:text-green-300 transition-all duration-100" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><title>Email</title><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a></div><div class="ml-auto flex flex-row items-center"><a class="inline-flex px-3 py-2 font-bold transition-all duration-100 hover:text-green-300" href="/">Home</a><a class="inline-flex px-3 py-2 font-bold transition-all duration-100 hover:text-green-300 underline decoration-4 underline-offset-8" href="/blog/">Blog</a></div></nav><main class="flex-grow"><div class="container mx-auto"><article><h1 class="mb-12 text-center text-5xl font-bold md:text-left md:text-6xl lg:text-7xl">How to learn software development</h1><div class="mb-6 text-lg"><time dateTime="2023-12-23T12:00:00.000Z">December	23, 2023</time></div><div class="mb-8 md:mb-16"><img class="shadow" alt="Cover Image for How to learn software development" src="/_next/static/media/how-to-learn-dev@1x.287725cd.png" srcSet="/_next/static/media/how-to-learn-dev@1x.287725cd.png 1x,/_next/static/media/how-to-learn-dev@2x.ec89749a.png 2x" width="512" height="256"/></div><div class="markdown-styles_markdown__JPpO_ mb-8"><h2>Intro</h2><p>The world of software development can seem like a never ending mountain of
skills to learn. As soon as you feel like you&#x27;re reaching a peak another starts
forming on the horizon. In many ways this is part of the appeal for a logical
thinker who enjoys the journey of learning, however it can understandably be
overwhelming for a newcomer trying to get started.</p><p>This post contains practical advice targeted at beginners who are interested in
getting started in the world of software development especially for those coming
from outside of computer science as I did from mathematics. It&#x27;s true that job
interviews suck and imposter syndrome is real but perseverance in the industry
is rewarded with a unique feeling of satisfaction.</p><h2>Learn a language</h2><p><img alt="language-basics" src="/_next/static/media/language-basics@1x.a80f29cc.png" srcSet="/_next/static/media/language-basics@1x.a80f29cc.png 1x,/_next/static/media/language-basics@2x.dc34d376.png 2x" width="512" height="256"/></p><p>First step is to learn the basics of a programming language.</p><p>This could be any of the popular general purpose programming languages such as
Python, Java, C#, JavaScript (TypeScript), Go. Incremental features have been
added to the older languages that have survived the test of time and have become
more modern and pleasant.</p><p>Over the course of many years it&#x27;s likely that you&#x27;ll end up picking up extra
languages for various reasons: forced to for new job, trying a new personal
project, writing automation scripts. The recurring theme is to focus on the
fundamentals which in this case means support for functions,
classes/interfaces/objects, if/else statements, for/while loops, static types,
generics. Language specific expertise can come over time such as how garbage
collection or advanced concurrency works. The importance of static types when it
comes to real software projects cannot be overlooked which means for dynamically
typed languages you should learn how to use the optional static typing features
such as type hints in Python or TypeScript over JavaScript.</p><p>The official language docs are often sufficient starting points for a complete
beginner to get up and running:</p><ul><li><a href="https://docs.python.org/3/tutorial/index.html" target="_blank" rel="nofollow noopener noreferrer">The Python Tutorial</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html" target="_blank" rel="nofollow noopener noreferrer">TypeScript for the New Programmer</a></li><li><a href="https://go.dev/tour/" target="_blank" rel="nofollow noopener noreferrer">A Tour of Go</a></li></ul><h2>Algorithms</h2><p><img alt="algorithms" src="/_next/static/media/algorithms@1x.33bbfead.png" srcSet="/_next/static/media/algorithms@1x.33bbfead.png 1x,/_next/static/media/algorithms@2x.7cbbc661.png 2x" width="512" height="256"/></p><p>The first reusable building blocks for solving problems with code are algorithms
and data structures. Although uncommon to need to implement these from scratch
in the real world, it&#x27;s important to have a solid understanding of them to have
a strong foundation and intuition for how to approach new problems in a
methodical manner.</p><p>All languages provide standard implementations of them for example a
<a href="https://en.wikipedia.org/wiki/Dynamic_array" target="_blank" rel="nofollow noopener noreferrer">dynamic array</a> which shows up
explicitly in Java as <code>ArrayList&lt;&gt;</code> or under the hood in Python as its <code>list</code>
type. Knowing how the standard tools in the toolkit work will help to recognise
which to apply and why to any new situation that comes up.</p><p>A non-comprehensive list of common data structures and algorithms I recommend
being comfortable with:</p><ul><li>Arrays</li><li>Linked lists</li><li>Stacks and queues</li><li>Binary search trees</li><li>Heaps and priority queues</li><li>Hash tables</li><li>Binary search</li><li>Depth first search (DFS) and breadth first search (BFS)</li><li>Dijkstra&#x27;s algorithm</li><li>Quicksort, merge sort, insertion sort</li><li>Topological sort</li><li>Union find</li></ul><p>The best way to study is a combination of resources of which there are plenty
available online. Just like learning a non-programming language requires
speaking, listening, reading and writing practice, the most effective way to
learn algorithms is a mix of theory and practical coding to reinforce
understanding.</p><p>Below are some of the resources I have personally found useful:</p><p><strong><em>Introduction to Algorithms</em></strong>
(<a href="https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/" target="_blank" rel="nofollow noopener noreferrer">https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/</a>)</p><p>Also known as CLRS after its authors (Cormen, Leiserson, Rivest, Stein), this
book is well known and deserves its reputation. It&#x27;s comprehensive and will be
easy to follow for those accustomed to formal proof of theorems for example from
mathematics. Depending on your interest more or less can be read but it is
useful to get the proper theoretical background on how algorithms work, why they
work and how fast they work (big O notation).</p><p><strong><em>HackerRank</em></strong> (<a href="https://www.hackerrank.com/" target="_blank" rel="nofollow noopener noreferrer">https://www.hackerrank.com/</a>)</p><p>Interactive coding platform containing a wide range of easy introductory
problems (as well as harder competitive programming style problems) useful for
familiarizing with language syntax and implementing common algorithms.</p><p><strong><em>Leetcode</em></strong> (<a href="https://leetcode.com/" target="_blank" rel="nofollow noopener noreferrer">https://leetcode.com/</a>)</p><p>Another interactive coding platform with a wide range of short algorithmic
problems often associated with spreading the algorithm job interview culture. It
is not worth spending over an hour stuck on a single problem in most cases -
there are always more to solve with the same pattern. If after reading the
solutions the problem is still too difficult you may benefit from going back to
studying theory. Most importantly stay positive as ultimately this does not
directly reflect software development and boils down to pattern matching.</p><h2>Developer tools</h2><p><img alt="developer-tools" src="/_next/static/media/developer-tools@1x.772b2c4d.png" srcSet="/_next/static/media/developer-tools@1x.772b2c4d.png 1x,/_next/static/media/developer-tools@2x.40a46e30.png 2x" width="512" height="256"/></p><p>As you work on larger projects you&#x27;ll need good developer tools to maintain
velocity, collaborate with others and deploy to production. A working level of
proficiency is expected in many of these core tools across the industry.
Although the technology world moves quickly, the categories of these tools
changes less often so learning how to use at least one of each type will help
transfer to others in the future.</p><p>Each of these deserve their own dedicated guide and require significant time
investment to truly be called an expert but working level proficiency can be
achieved in relatively shorter time. Start off gradually with a basic awareness
of what these tools are and learn them as you need them. A brief overview of
what tools to look into is given below.</p><p><strong><em>Operating system and shell</em></strong></p><p>Production servers overwhelming run Linux due to its stability, security and
being free and open source software (FOSS). Many other projects and developer
tools work best or only work on Unix-like operating systems. Therefore, my
recommendation is to use Linux or macOS for your developer machine, or Linux on
Windows through
<a href="https://learn.microsoft.com/en-us/windows/wsl/about" target="_blank" rel="nofollow noopener noreferrer">Windows Subsystem for Linux (WSL)</a>
while developing. <a href="https://ubuntu.com/" target="_blank" rel="nofollow noopener noreferrer">Ubuntu</a> is a popular Linux distribution
to start with. Exceptions exist for platform specific development such as
Windows for the C# ecosystem with .NET and Visual Studio and macOS for the Apple
ecosystem with Swift.</p><p>To interact with your operating system you will spend a lot of time using the
terminal with a shell such as <a href="https://www.gnu.org/software/bash/" target="_blank" rel="nofollow noopener noreferrer">Bash</a> which
is the default in many Linux distributions including Ubuntu. On your local
development machine you will also have access to a user interface for example
for the file system, Git and Docker. However you will commonly need to work on
remote servers via SSH to debug production applications or as a cloud
development workspace. Comfort with using Linux and the terminal to perform your
everyday tasks will make it easier to transition to working with remote servers.</p><p>Here is a list of command line programs I frequently use:</p><ul><li>File system navigation - <code>ls</code>, <code>cd</code>, <code>pwd</code>, <code>tree</code>, <code>mkdir</code>, <code>rm</code>, <code>touch</code></li><li>File system search - <code>grep</code>, <code>find</code>, <code>which</code>, <code>env</code></li><li>File and string manipulation - <code>vim</code>, <code>cat</code>, <code>echo</code>, <code>head</code>, <code>tail</code>, <code>cut</code>,
<code>sed</code>, <code>jq</code></li><li>File compression - <code>zip</code>, <code>unzip</code>, <code>tar</code></li><li>Network requests - <code>curl</code>, <code>wget</code>, <code>openssl</code></li><li>Resource management - <code>top</code>, <code>ps</code>, <code>kill</code>, <code>free</code></li><li>Other - <code>tmux</code>, <code>ssh</code>, <code>git</code>, <code>docker</code></li></ul><p>It is convention to store shell and program user settings in dotfiles in the
user home directory for example <code>~/.bashrc</code> and <code>~/.gitconfig</code>. Eventually you
may version these in your own <a href="https://dotfiles.github.io/" target="_blank" rel="nofollow noopener noreferrer">dotfiles repository</a>
to make it easier to bootstrap any new development machine or remote cloud
workspace with your preferences.</p><p><strong><em>Integrated developer environment (IDE)</em></strong></p><p>To write, run, test and debug code an integrated developer environment (IDE) is
used. While this can technically be done solely in the terminal with a program
like <code>vim</code> with considerable customisation there&#x27;s often a more popular choice
for the specific language or target device.</p><p>For a lightweight easy to use code editor
<a href="https://code.visualstudio.com/" target="_blank" rel="nofollow noopener noreferrer">VSCode</a> is a good option with strong built in
support for TypeScript and its rich ecosystem of extensions allows it to be
transformed into an IDE for any language.</p><p>For a more heavyweight feature rich out of the box IDE consider Visual Studio,
IntelliJ IDEA, PyCharm, GoLand depending on your language.</p><p><strong><em>Version control system (VCS)</em></strong></p><p>Source code must be managed well to handle the complexity of developers
collaborating on features and bug fixes asynchronously in their own independent
environments. The most popular version control system (VCS) for this is
<a href="https://git-scm.com/" target="_blank" rel="nofollow noopener noreferrer">Git</a> and the most popular remote repository hosting
service is <a href="https://github.com/" target="_blank" rel="nofollow noopener noreferrer">GitHub</a>.</p><p>Given the universal adoption of Git, IDEs provide deep integration with it which
can be helpful but you should be familiar with operating with <code>git</code> from the
terminal as well.</p><p>Common workflows with Git include:</p><ul><li>Creating and cloning a Git repository - <code>git init</code>, <code>git clone</code></li><li>Committing and pushing a Git repository - <code>git add</code>, <code>git status</code>,
<code>git commit</code>, <code>git push</code></li><li>Setting up Git branches and fetching new upstream changes - <code>git branch</code>,
<code>git checkout</code>, <code>git fetch</code>, <code>git pull</code>, <code>git remote</code></li><li>Merging and rebasing Git branches including resolving merge conflicts -
<code>git merge</code>, <code>git rebase</code></li><li>Managing multiple development branches - <code>git worktree</code></li></ul><p><strong><em>Continuous integration and deployment (CI/CD)</em></strong></p><p>For a software project to keep high velocity it&#x27;s critical that the main branch
always builds successfully and is deployed often for rapid iteration. This
involves tasks such as installing dependencies, compiling, linting, testing,
building and publishing artifacts against pushed commits and tags. Rather than
have a developer manually perform these steps this is automated in a continuous
integration and deployment (CI/CD) pipeline.</p><p>There exist multiple providers but
<a href="https://docs.github.com/en/actions" target="_blank" rel="nofollow noopener noreferrer">GitHub Actions</a> is an obvious choice to
start with if your Git repositories are already hosted on GitHub.</p><p><strong><em>Build system</em></strong></p><p>During both CI/CD and local development the dependency graph between project
tasks becomes difficult to manage manually. For example, if a line of source
code is changed in a subproject you need to know in order to rerun tests the
relevant source code and its dependencies must be recompiled otherwise the test
results will be stale. We could just recompile all code in the project but that
becomes slow and inefficient for large monorepo style projects. Furthermore, if
the inputs haven&#x27;t changed the results can be cached and reused across
independent CI runs saving lots of time.</p><p>The need for efficient and correct builds leads to using a build system.
Examples include Bazel, Gradle, Ant, Make and Turbo. Each language ecosystem may
have build systems specifically designed for them. <a href="https://bazel.build/" target="_blank" rel="nofollow noopener noreferrer">Bazel</a>
is a solid language and platform agnostic build system to choose.</p><p><strong><em>Cloud</em></strong></p><p>Production applications need to run on servers somewhere. Historically that
meant renting dedicated machines in data centres but today the default option is
using virtual machines (VMs) in the cloud. This enables low cost commodity
hardware resources to be shared securely between multiple customers and scaled
elastically depending on demand.</p><p>Possibilities include managing the VMs on the cloud and deploying to the VMs
yourself as Infrastructure as a Service (IaaS) or providing application code in
the form of containers or otherwise to be managed and run on the cloud directly
as Platform as a Service (PaaS).</p><p>The main players are <a href="https://aws.amazon.com/" target="_blank" rel="nofollow noopener noreferrer">Amazon Web Services</a> (AWS),
<a href="https://cloud.google.com/" target="_blank" rel="nofollow noopener noreferrer">Google Cloud Platform</a> (GCP) and
<a href="https://azure.microsoft.com/" target="_blank" rel="nofollow noopener noreferrer">Microsoft Azure</a>. Each platform offers some quota
of services under a free tier to get started and it&#x27;s best to start off with
just one of them to benefit from the whole integrated platform.</p><p><strong><em>Containers</em></strong></p><p>Running software in different environments is hard. Even between developers on a
single team with the same model hardware it&#x27;s frequent to hear the saying &quot;it
works on my machine!&quot;. Containers exist to solve this problem by packaging an
application together with its dependencies to run in a reproducible environment.
The overhead is less compared to VMs due to the host operating system kernel
being shared across containers.</p><p>There exist standard specifications for containers by the Open Container
Initiative (OCI). <a href="https://www.docker.com/" target="_blank" rel="nofollow noopener noreferrer">Docker</a> heavily contributed to the
OCI and is the default platform for developers to build OCI compliant images and
run containers. To run containers in production an orchestration system such as
<a href="https://kubernetes.io/" target="_blank" rel="nofollow noopener noreferrer">Kubernetes</a> (k8s) is used which under the hood can use
different container runtimes including <code>containerd</code> which was originally split
out from Docker during attempts to make it more modular.</p><p>Common workflows with the Docker CLI include:</p><ul><li>Building an image from a Dockerfile - <code>docker build</code></li><li>Running a container from an image in a registry - <code>docker run</code></li><li>Attaching to a running container and inspecting logs - <code>docker ps</code>,
<code>docker exec</code>, <code>docker logs</code></li><li>Stopping and removing containers - <code>docker stop</code>, <code>docker rm</code></li><li>Managing locally pulled images - <code>docker pull</code>, <code>docker images</code></li></ul><p><strong><em>Design</em></strong></p><p>Design tools can be used to mock user interfaces and information architecture of
applications and a company may have Product Designers for this purpose. They are
still valuable for developers to create architecture diagrams as an important
step in the software development lifecycle to plan implementation and gather
feedback from teams.</p><p><a href="https://figma.com/" target="_blank" rel="nofollow noopener noreferrer">Figma</a> is the best full featured collaborative design
platform today. The images in this blog were all created in Figma! Other
lightweight options to experiment with are Excalidraw and draw.io.</p><h2>Projects</h2><p><img alt="projects" src="/_next/static/media/projects@1x.094fa73b.png" srcSet="/_next/static/media/projects@1x.094fa73b.png 1x,/_next/static/media/projects@2x.0b9e4455.png 2x" width="256" height="256"/></p><p>Software development is creative! The joy is in the huge variety of projects
that can be worked on.</p><p>Find your passion. If you enjoy algorithms you might continue studying theory
and join competitive programming contests. If you enjoy user facing applications
you might try to build and deploy an app to help others. If you enjoy AI/ML you
might try to train your own model for a bespoke task.</p><p>This is highly personal and dependent on your own interest but some ideas if
you&#x27;re struggling:</p><ul><li>Script to automate task you find yourself repeating</li><li>Command line interface (CLI) to interact with an external service from the
terminal</li><li>Web/mobile/desktop application</li><li>Personal website/blog</li><li>Large language models (LLMs) applied to a new area of interest</li><li>Simple database implementation from scratch</li><li>Small bug fixes in open source projects</li></ul><p>Don&#x27;t worry about how large or small a project is, the biggest challenge is
getting started.</p><p>As well as exploring your own projects, I recommend spending lots and lots of
time reading other codebases. This will help as inspiration for your own
projects, teach you new programming tricks and open your mind to various styles
of writing code. You will eventually form your own opinions and code style after
years of reading and writing code. Try to start from a user facing string in a
piece of software you use and reverse engineer how the system works from
searching the source code. Doing this improves your debugging skills and
decreases the time it will take you to onboard onto a new codebase in the
future.</p><p>Use this as an opportunity to put into practice the developer tools you&#x27;ve
learned at a small enough scale that you can see the whole picture. At larger
companies there may be abstractions on top of tools or internally developed
substitutes for them to streamline processes and enforce consistency which
increase developer productivity but also make it easy to skip understanding the
fundamentals behind them. For example, set up your own CI/CD pipeline for your
code repository from scratch which will save you time in the long run and teach
yourself valuable skills.</p><p>Below are some extra thoughts and resources:</p><p><strong><em>Contributing to open source</em></strong></p><p>Giving back to the developer community can be one of the most rewarding ways to
spend time and a lot of the code we rely on depends on the hard work of the
people working on open source projects. A word of warning though that,
especially as a beginner, it is not realistic to contribute to the largest open
source projects without a considerable time investment on all sides. In fact,
some maintainers may take the stance that no external contributions are accepted
to avoid the potential discouraging experience for everyone.</p><p>If going down this route, it&#x27;s best to focus on small less controversial changes
such as documentation and small bug fixes while demonstrating good communication
and commitment which may grow into a longer term relationship of trust. Look for
smaller open source projects which may have more bandwidth and a shortage of
contributors. A personal motivation behind a contribution may also improve your
chances of keeping morale up for example if it would allow you to remove a
workaround in your own application code.</p><p><strong><em>Clean Code</em></strong>
(<a href="https://www.oreilly.com/library/view/clean-code-a/9780136083238/" target="_blank" rel="nofollow noopener noreferrer">https://www.oreilly.com/library/view/clean-code-a/9780136083238/</a>)</p><p>A well liked book for teaching guidelines to follow when writing code including
don&#x27;t repeat yourself (DRY) and keep it simple stupid (KISS). Worth reading
early on to form intuition on what good or bad code may look like and why. As
with most advice, it&#x27;s important to be open minded and not treat it as rules set
in stone that can never be broken - exceptions always exist.</p><p><strong><em>Design Patterns</em></strong>
(<a href="https://www.oreilly.com/library/view/design-patterns-elements/0201633612/" target="_blank" rel="nofollow noopener noreferrer">https://www.oreilly.com/library/view/design-patterns-elements/0201633612/</a>)</p><p>Also known as the &quot;Gang of Four&quot; design patterns book which prescribes and gives
names to object oriented programming solutions for repeatedly seen software
problems. This book requires some experience in writing object oriented
programming, however it is likely that while reading any established codebase
you will spot at least one of the design patterns inside. Similar to how
algorithms share knowledge of building blocks of code, design patterns share
knowledge of building blocks of objects.</p><h2>Conclusion</h2><p>The best advice I can give is to stay curious and keep writing code. We all look
back at early code we have written and laugh or feel embarrassed but writing
code that serves a purpose to people and enjoying the journey along the way is
what matters. At a certain point the pieces will start to click together and
you&#x27;ll look behind at the mountain you&#x27;ve climbed and look forward to the next
one ahead.</p><p>I hope that this has been useful as it would have been for me at the start of my
career! If you have any questions you are welcome to reach out.</p></div><div class="py-8"><a class="inline-flex items-center font-bold transition-all duration-100 hover:text-green-300" href="/blog/"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="mr-1" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>Back to all posts</a></div></article></div></main><footer class="py-8">Tim Leung 2025</footer></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"slug":"how-to-learn-dev","title":"How to learn software development","excerpt":"Practical advice for beginners","date":"2023-12-23T12:00:00.000Z","coverImage":"blog/how-to-learn-dev/how-to-learn-dev.png","ogImage":"blog/how-to-learn-dev/how-to-learn-dev.png","content":"\n## Intro\n\nThe world of software development can seem like a never ending mountain of\nskills to learn. As soon as you feel like you're reaching a peak another starts\nforming on the horizon. In many ways this is part of the appeal for a logical\nthinker who enjoys the journey of learning, however it can understandably be\noverwhelming for a newcomer trying to get started.\n\nThis post contains practical advice targeted at beginners who are interested in\ngetting started in the world of software development especially for those coming\nfrom outside of computer science as I did from mathematics. It's true that job\ninterviews suck and imposter syndrome is real but perseverance in the industry\nis rewarded with a unique feeling of satisfaction.\n\n## Learn a language\n\n![language-basics](blog/how-to-learn-dev/language-basics.png)\n\nFirst step is to learn the basics of a programming language.\n\nThis could be any of the popular general purpose programming languages such as\nPython, Java, C#, JavaScript (TypeScript), Go. Incremental features have been\nadded to the older languages that have survived the test of time and have become\nmore modern and pleasant.\n\nOver the course of many years it's likely that you'll end up picking up extra\nlanguages for various reasons: forced to for new job, trying a new personal\nproject, writing automation scripts. The recurring theme is to focus on the\nfundamentals which in this case means support for functions,\nclasses/interfaces/objects, if/else statements, for/while loops, static types,\ngenerics. Language specific expertise can come over time such as how garbage\ncollection or advanced concurrency works. The importance of static types when it\ncomes to real software projects cannot be overlooked which means for dynamically\ntyped languages you should learn how to use the optional static typing features\nsuch as type hints in Python or TypeScript over JavaScript.\n\nThe official language docs are often sufficient starting points for a complete\nbeginner to get up and running:\n\n- [The Python Tutorial](https://docs.python.org/3/tutorial/index.html)\n- [TypeScript for the New Programmer](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)\n- [A Tour of Go](https://go.dev/tour/)\n\n## Algorithms\n\n![algorithms](blog/how-to-learn-dev/algorithms.png)\n\nThe first reusable building blocks for solving problems with code are algorithms\nand data structures. Although uncommon to need to implement these from scratch\nin the real world, it's important to have a solid understanding of them to have\na strong foundation and intuition for how to approach new problems in a\nmethodical manner.\n\nAll languages provide standard implementations of them for example a\n[dynamic array](https://en.wikipedia.org/wiki/Dynamic_array) which shows up\nexplicitly in Java as `ArrayList\u003c\u003e` or under the hood in Python as its `list`\ntype. Knowing how the standard tools in the toolkit work will help to recognise\nwhich to apply and why to any new situation that comes up.\n\nA non-comprehensive list of common data structures and algorithms I recommend\nbeing comfortable with:\n\n- Arrays\n- Linked lists\n- Stacks and queues\n- Binary search trees\n- Heaps and priority queues\n- Hash tables\n- Binary search\n- Depth first search (DFS) and breadth first search (BFS)\n- Dijkstra's algorithm\n- Quicksort, merge sort, insertion sort\n- Topological sort\n- Union find\n\nThe best way to study is a combination of resources of which there are plenty\navailable online. Just like learning a non-programming language requires\nspeaking, listening, reading and writing practice, the most effective way to\nlearn algorithms is a mix of theory and practical coding to reinforce\nunderstanding.\n\nBelow are some of the resources I have personally found useful:\n\n**_Introduction to Algorithms_**\n(https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/)\n\nAlso known as CLRS after its authors (Cormen, Leiserson, Rivest, Stein), this\nbook is well known and deserves its reputation. It's comprehensive and will be\neasy to follow for those accustomed to formal proof of theorems for example from\nmathematics. Depending on your interest more or less can be read but it is\nuseful to get the proper theoretical background on how algorithms work, why they\nwork and how fast they work (big O notation).\n\n**_HackerRank_** (https://www.hackerrank.com/)\n\nInteractive coding platform containing a wide range of easy introductory\nproblems (as well as harder competitive programming style problems) useful for\nfamiliarizing with language syntax and implementing common algorithms.\n\n**_Leetcode_** (https://leetcode.com/)\n\nAnother interactive coding platform with a wide range of short algorithmic\nproblems often associated with spreading the algorithm job interview culture. It\nis not worth spending over an hour stuck on a single problem in most cases -\nthere are always more to solve with the same pattern. If after reading the\nsolutions the problem is still too difficult you may benefit from going back to\nstudying theory. Most importantly stay positive as ultimately this does not\ndirectly reflect software development and boils down to pattern matching.\n\n## Developer tools\n\n![developer-tools](blog/how-to-learn-dev/developer-tools.png)\n\nAs you work on larger projects you'll need good developer tools to maintain\nvelocity, collaborate with others and deploy to production. A working level of\nproficiency is expected in many of these core tools across the industry.\nAlthough the technology world moves quickly, the categories of these tools\nchanges less often so learning how to use at least one of each type will help\ntransfer to others in the future.\n\nEach of these deserve their own dedicated guide and require significant time\ninvestment to truly be called an expert but working level proficiency can be\nachieved in relatively shorter time. Start off gradually with a basic awareness\nof what these tools are and learn them as you need them. A brief overview of\nwhat tools to look into is given below.\n\n**_Operating system and shell_**\n\nProduction servers overwhelming run Linux due to its stability, security and\nbeing free and open source software (FOSS). Many other projects and developer\ntools work best or only work on Unix-like operating systems. Therefore, my\nrecommendation is to use Linux or macOS for your developer machine, or Linux on\nWindows through\n[Windows Subsystem for Linux (WSL)](https://learn.microsoft.com/en-us/windows/wsl/about)\nwhile developing. [Ubuntu](https://ubuntu.com/) is a popular Linux distribution\nto start with. Exceptions exist for platform specific development such as\nWindows for the C# ecosystem with .NET and Visual Studio and macOS for the Apple\necosystem with Swift.\n\nTo interact with your operating system you will spend a lot of time using the\nterminal with a shell such as [Bash](https://www.gnu.org/software/bash/) which\nis the default in many Linux distributions including Ubuntu. On your local\ndevelopment machine you will also have access to a user interface for example\nfor the file system, Git and Docker. However you will commonly need to work on\nremote servers via SSH to debug production applications or as a cloud\ndevelopment workspace. Comfort with using Linux and the terminal to perform your\neveryday tasks will make it easier to transition to working with remote servers.\n\nHere is a list of command line programs I frequently use:\n\n- File system navigation - `ls`, `cd`, `pwd`, `tree`, `mkdir`, `rm`, `touch`\n- File system search - `grep`, `find`, `which`, `env`\n- File and string manipulation - `vim`, `cat`, `echo`, `head`, `tail`, `cut`,\n  `sed`, `jq`\n- File compression - `zip`, `unzip`, `tar`\n- Network requests - `curl`, `wget`, `openssl`\n- Resource management - `top`, `ps`, `kill`, `free`\n- Other - `tmux`, `ssh`, `git`, `docker`\n\nIt is convention to store shell and program user settings in dotfiles in the\nuser home directory for example `~/.bashrc` and `~/.gitconfig`. Eventually you\nmay version these in your own [dotfiles repository](https://dotfiles.github.io/)\nto make it easier to bootstrap any new development machine or remote cloud\nworkspace with your preferences.\n\n**_Integrated developer environment (IDE)_**\n\nTo write, run, test and debug code an integrated developer environment (IDE) is\nused. While this can technically be done solely in the terminal with a program\nlike `vim` with considerable customisation there's often a more popular choice\nfor the specific language or target device.\n\nFor a lightweight easy to use code editor\n[VSCode](https://code.visualstudio.com/) is a good option with strong built in\nsupport for TypeScript and its rich ecosystem of extensions allows it to be\ntransformed into an IDE for any language.\n\nFor a more heavyweight feature rich out of the box IDE consider Visual Studio,\nIntelliJ IDEA, PyCharm, GoLand depending on your language.\n\n**_Version control system (VCS)_**\n\nSource code must be managed well to handle the complexity of developers\ncollaborating on features and bug fixes asynchronously in their own independent\nenvironments. The most popular version control system (VCS) for this is\n[Git](https://git-scm.com/) and the most popular remote repository hosting\nservice is [GitHub](https://github.com/).\n\nGiven the universal adoption of Git, IDEs provide deep integration with it which\ncan be helpful but you should be familiar with operating with `git` from the\nterminal as well.\n\nCommon workflows with Git include:\n\n- Creating and cloning a Git repository - `git init`, `git clone`\n- Committing and pushing a Git repository - `git add`, `git status`,\n  `git commit`, `git push`\n- Setting up Git branches and fetching new upstream changes - `git branch`,\n  `git checkout`, `git fetch`, `git pull`, `git remote`\n- Merging and rebasing Git branches including resolving merge conflicts -\n  `git merge`, `git rebase`\n- Managing multiple development branches - `git worktree`\n\n**_Continuous integration and deployment (CI/CD)_**\n\nFor a software project to keep high velocity it's critical that the main branch\nalways builds successfully and is deployed often for rapid iteration. This\ninvolves tasks such as installing dependencies, compiling, linting, testing,\nbuilding and publishing artifacts against pushed commits and tags. Rather than\nhave a developer manually perform these steps this is automated in a continuous\nintegration and deployment (CI/CD) pipeline.\n\nThere exist multiple providers but\n[GitHub Actions](https://docs.github.com/en/actions) is an obvious choice to\nstart with if your Git repositories are already hosted on GitHub.\n\n**_Build system_**\n\nDuring both CI/CD and local development the dependency graph between project\ntasks becomes difficult to manage manually. For example, if a line of source\ncode is changed in a subproject you need to know in order to rerun tests the\nrelevant source code and its dependencies must be recompiled otherwise the test\nresults will be stale. We could just recompile all code in the project but that\nbecomes slow and inefficient for large monorepo style projects. Furthermore, if\nthe inputs haven't changed the results can be cached and reused across\nindependent CI runs saving lots of time.\n\nThe need for efficient and correct builds leads to using a build system.\nExamples include Bazel, Gradle, Ant, Make and Turbo. Each language ecosystem may\nhave build systems specifically designed for them. [Bazel](https://bazel.build/)\nis a solid language and platform agnostic build system to choose.\n\n**_Cloud_**\n\nProduction applications need to run on servers somewhere. Historically that\nmeant renting dedicated machines in data centres but today the default option is\nusing virtual machines (VMs) in the cloud. This enables low cost commodity\nhardware resources to be shared securely between multiple customers and scaled\nelastically depending on demand.\n\nPossibilities include managing the VMs on the cloud and deploying to the VMs\nyourself as Infrastructure as a Service (IaaS) or providing application code in\nthe form of containers or otherwise to be managed and run on the cloud directly\nas Platform as a Service (PaaS).\n\nThe main players are [Amazon Web Services](https://aws.amazon.com/) (AWS),\n[Google Cloud Platform](https://cloud.google.com/) (GCP) and\n[Microsoft Azure](https://azure.microsoft.com/). Each platform offers some quota\nof services under a free tier to get started and it's best to start off with\njust one of them to benefit from the whole integrated platform.\n\n**_Containers_**\n\nRunning software in different environments is hard. Even between developers on a\nsingle team with the same model hardware it's frequent to hear the saying \"it\nworks on my machine!\". Containers exist to solve this problem by packaging an\napplication together with its dependencies to run in a reproducible environment.\nThe overhead is less compared to VMs due to the host operating system kernel\nbeing shared across containers.\n\nThere exist standard specifications for containers by the Open Container\nInitiative (OCI). [Docker](https://www.docker.com/) heavily contributed to the\nOCI and is the default platform for developers to build OCI compliant images and\nrun containers. To run containers in production an orchestration system such as\n[Kubernetes](https://kubernetes.io/) (k8s) is used which under the hood can use\ndifferent container runtimes including `containerd` which was originally split\nout from Docker during attempts to make it more modular.\n\nCommon workflows with the Docker CLI include:\n\n- Building an image from a Dockerfile - `docker build`\n- Running a container from an image in a registry - `docker run`\n- Attaching to a running container and inspecting logs - `docker ps`,\n  `docker exec`, `docker logs`\n- Stopping and removing containers - `docker stop`, `docker rm`\n- Managing locally pulled images - `docker pull`, `docker images`\n\n**_Design_**\n\nDesign tools can be used to mock user interfaces and information architecture of\napplications and a company may have Product Designers for this purpose. They are\nstill valuable for developers to create architecture diagrams as an important\nstep in the software development lifecycle to plan implementation and gather\nfeedback from teams.\n\n[Figma](https://figma.com/) is the best full featured collaborative design\nplatform today. The images in this blog were all created in Figma! Other\nlightweight options to experiment with are Excalidraw and draw.io.\n\n## Projects\n\n![projects](blog/how-to-learn-dev/projects.png)\n\nSoftware development is creative! The joy is in the huge variety of projects\nthat can be worked on.\n\nFind your passion. If you enjoy algorithms you might continue studying theory\nand join competitive programming contests. If you enjoy user facing applications\nyou might try to build and deploy an app to help others. If you enjoy AI/ML you\nmight try to train your own model for a bespoke task.\n\nThis is highly personal and dependent on your own interest but some ideas if\nyou're struggling:\n\n- Script to automate task you find yourself repeating\n- Command line interface (CLI) to interact with an external service from the\n  terminal\n- Web/mobile/desktop application\n- Personal website/blog\n- Large language models (LLMs) applied to a new area of interest\n- Simple database implementation from scratch\n- Small bug fixes in open source projects\n\nDon't worry about how large or small a project is, the biggest challenge is\ngetting started.\n\nAs well as exploring your own projects, I recommend spending lots and lots of\ntime reading other codebases. This will help as inspiration for your own\nprojects, teach you new programming tricks and open your mind to various styles\nof writing code. You will eventually form your own opinions and code style after\nyears of reading and writing code. Try to start from a user facing string in a\npiece of software you use and reverse engineer how the system works from\nsearching the source code. Doing this improves your debugging skills and\ndecreases the time it will take you to onboard onto a new codebase in the\nfuture.\n\nUse this as an opportunity to put into practice the developer tools you've\nlearned at a small enough scale that you can see the whole picture. At larger\ncompanies there may be abstractions on top of tools or internally developed\nsubstitutes for them to streamline processes and enforce consistency which\nincrease developer productivity but also make it easy to skip understanding the\nfundamentals behind them. For example, set up your own CI/CD pipeline for your\ncode repository from scratch which will save you time in the long run and teach\nyourself valuable skills.\n\nBelow are some extra thoughts and resources:\n\n**_Contributing to open source_**\n\nGiving back to the developer community can be one of the most rewarding ways to\nspend time and a lot of the code we rely on depends on the hard work of the\npeople working on open source projects. A word of warning though that,\nespecially as a beginner, it is not realistic to contribute to the largest open\nsource projects without a considerable time investment on all sides. In fact,\nsome maintainers may take the stance that no external contributions are accepted\nto avoid the potential discouraging experience for everyone.\n\nIf going down this route, it's best to focus on small less controversial changes\nsuch as documentation and small bug fixes while demonstrating good communication\nand commitment which may grow into a longer term relationship of trust. Look for\nsmaller open source projects which may have more bandwidth and a shortage of\ncontributors. A personal motivation behind a contribution may also improve your\nchances of keeping morale up for example if it would allow you to remove a\nworkaround in your own application code.\n\n**_Clean Code_**\n(https://www.oreilly.com/library/view/clean-code-a/9780136083238/)\n\nA well liked book for teaching guidelines to follow when writing code including\ndon't repeat yourself (DRY) and keep it simple stupid (KISS). Worth reading\nearly on to form intuition on what good or bad code may look like and why. As\nwith most advice, it's important to be open minded and not treat it as rules set\nin stone that can never be broken - exceptions always exist.\n\n**_Design Patterns_**\n(https://www.oreilly.com/library/view/design-patterns-elements/0201633612/)\n\nAlso known as the \"Gang of Four\" design patterns book which prescribes and gives\nnames to object oriented programming solutions for repeatedly seen software\nproblems. This book requires some experience in writing object oriented\nprogramming, however it is likely that while reading any established codebase\nyou will spot at least one of the design patterns inside. Similar to how\nalgorithms share knowledge of building blocks of code, design patterns share\nknowledge of building blocks of objects.\n\n## Conclusion\n\nThe best advice I can give is to stay curious and keep writing code. We all look\nback at early code we have written and laugh or feel embarrassed but writing\ncode that serves a purpose to people and enjoying the journey along the way is\nwhat matters. At a certain point the pieces will start to click together and\nyou'll look behind at the mountain you've climbed and look forward to the next\none ahead.\n\nI hope that this has been useful as it would have been for me at the start of my\ncareer! If you have any questions you are welcome to reach out.\n","mdxSource":{"compiledSource":"var m=Object.defineProperty,c=Object.defineProperties;var h=Object.getOwnPropertyDescriptors;var a=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,l=Object.prototype.propertyIsEnumerable;var s=(o,n,t)=\u003en in o?m(o,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[n]=t,e=(o,n)=\u003e{for(var t in n||(n={}))r.call(n,t)\u0026\u0026s(o,t,n[t]);if(a)for(var t of a(n))l.call(n,t)\u0026\u0026s(o,t,n[t]);return o},p=(o,n)=\u003ec(o,h(n));var d=(o,n)=\u003e{var t={};for(var i in o)r.call(o,i)\u0026\u0026n.indexOf(i)\u003c0\u0026\u0026(t[i]=o[i]);if(o!=null\u0026\u0026a)for(var i of a(o))n.indexOf(i)\u003c0\u0026\u0026l.call(o,i)\u0026\u0026(t[i]=o[i]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var i=t,{components:o}=i,n=d(i,[\"components\"]);return mdx(MDXLayout,p(e(e({},layoutProps),n),{components:o,mdxType:\"MDXLayout\"}),mdx(\"h2\",null,\"Intro\"),mdx(\"p\",null,`The world of software development can seem like a never ending mountain of\nskills to learn. As soon as you feel like you're reaching a peak another starts\nforming on the horizon. In many ways this is part of the appeal for a logical\nthinker who enjoys the journey of learning, however it can understandably be\noverwhelming for a newcomer trying to get started.`),mdx(\"p\",null,`This post contains practical advice targeted at beginners who are interested in\ngetting started in the world of software development especially for those coming\nfrom outside of computer science as I did from mathematics. It's true that job\ninterviews suck and imposter syndrome is real but perseverance in the industry\nis rewarded with a unique feeling of satisfaction.`),mdx(\"h2\",null,\"Learn a language\"),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"blog/how-to-learn-dev/language-basics.png\",alt:\"language-basics\"}))),mdx(\"p\",null,\"First step is to learn the basics of a programming language.\"),mdx(\"p\",null,`This could be any of the popular general purpose programming languages such as\nPython, Java, C#, JavaScript (TypeScript), Go. Incremental features have been\nadded to the older languages that have survived the test of time and have become\nmore modern and pleasant.`),mdx(\"p\",null,`Over the course of many years it's likely that you'll end up picking up extra\nlanguages for various reasons: forced to for new job, trying a new personal\nproject, writing automation scripts. The recurring theme is to focus on the\nfundamentals which in this case means support for functions,\nclasses/interfaces/objects, if/else statements, for/while loops, static types,\ngenerics. Language specific expertise can come over time such as how garbage\ncollection or advanced concurrency works. The importance of static types when it\ncomes to real software projects cannot be overlooked which means for dynamically\ntyped languages you should learn how to use the optional static typing features\nsuch as type hints in Python or TypeScript over JavaScript.`),mdx(\"p\",null,`The official language docs are often sufficient starting points for a complete\nbeginner to get up and running:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"a\",e({parentName:\"li\"},{href:\"https://docs.python.org/3/tutorial/index.html\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"The Python Tutorial\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"a\",e({parentName:\"li\"},{href:\"https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"TypeScript for the New Programmer\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"a\",e({parentName:\"li\"},{href:\"https://go.dev/tour/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"A Tour of Go\"))),mdx(\"h2\",null,\"Algorithms\"),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"blog/how-to-learn-dev/algorithms.png\",alt:\"algorithms\"}))),mdx(\"p\",null,`The first reusable building blocks for solving problems with code are algorithms\nand data structures. Although uncommon to need to implement these from scratch\nin the real world, it's important to have a solid understanding of them to have\na strong foundation and intuition for how to approach new problems in a\nmethodical manner.`),mdx(\"p\",null,`All languages provide standard implementations of them for example a\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://en.wikipedia.org/wiki/Dynamic_array\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"dynamic array\"),` which shows up\nexplicitly in Java as `,mdx(\"inlineCode\",{parentName:\"p\"},\"ArrayList\u003c\u003e\"),\" or under the hood in Python as its \",mdx(\"inlineCode\",{parentName:\"p\"},\"list\"),`\ntype. Knowing how the standard tools in the toolkit work will help to recognise\nwhich to apply and why to any new situation that comes up.`),mdx(\"p\",null,`A non-comprehensive list of common data structures and algorithms I recommend\nbeing comfortable with:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Arrays\"),mdx(\"li\",{parentName:\"ul\"},\"Linked lists\"),mdx(\"li\",{parentName:\"ul\"},\"Stacks and queues\"),mdx(\"li\",{parentName:\"ul\"},\"Binary search trees\"),mdx(\"li\",{parentName:\"ul\"},\"Heaps and priority queues\"),mdx(\"li\",{parentName:\"ul\"},\"Hash tables\"),mdx(\"li\",{parentName:\"ul\"},\"Binary search\"),mdx(\"li\",{parentName:\"ul\"},\"Depth first search (DFS) and breadth first search (BFS)\"),mdx(\"li\",{parentName:\"ul\"},\"Dijkstra's algorithm\"),mdx(\"li\",{parentName:\"ul\"},\"Quicksort, merge sort, insertion sort\"),mdx(\"li\",{parentName:\"ul\"},\"Topological sort\"),mdx(\"li\",{parentName:\"ul\"},\"Union find\")),mdx(\"p\",null,`The best way to study is a combination of resources of which there are plenty\navailable online. Just like learning a non-programming language requires\nspeaking, listening, reading and writing practice, the most effective way to\nlearn algorithms is a mix of theory and practical coding to reinforce\nunderstanding.`),mdx(\"p\",null,\"Below are some of the resources I have personally found useful:\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Introduction to Algorithms\")),`\n(`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/\"),\")\"),mdx(\"p\",null,`Also known as CLRS after its authors (Cormen, Leiserson, Rivest, Stein), this\nbook is well known and deserves its reputation. It's comprehensive and will be\neasy to follow for those accustomed to formal proof of theorems for example from\nmathematics. Depending on your interest more or less can be read but it is\nuseful to get the proper theoretical background on how algorithms work, why they\nwork and how fast they work (big O notation).`),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"HackerRank\")),\" (\",mdx(\"a\",e({parentName:\"p\"},{href:\"https://www.hackerrank.com/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"https://www.hackerrank.com/\"),\")\"),mdx(\"p\",null,`Interactive coding platform containing a wide range of easy introductory\nproblems (as well as harder competitive programming style problems) useful for\nfamiliarizing with language syntax and implementing common algorithms.`),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Leetcode\")),\" (\",mdx(\"a\",e({parentName:\"p\"},{href:\"https://leetcode.com/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"https://leetcode.com/\"),\")\"),mdx(\"p\",null,`Another interactive coding platform with a wide range of short algorithmic\nproblems often associated with spreading the algorithm job interview culture. It\nis not worth spending over an hour stuck on a single problem in most cases -\nthere are always more to solve with the same pattern. If after reading the\nsolutions the problem is still too difficult you may benefit from going back to\nstudying theory. Most importantly stay positive as ultimately this does not\ndirectly reflect software development and boils down to pattern matching.`),mdx(\"h2\",null,\"Developer tools\"),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"blog/how-to-learn-dev/developer-tools.png\",alt:\"developer-tools\"}))),mdx(\"p\",null,`As you work on larger projects you'll need good developer tools to maintain\nvelocity, collaborate with others and deploy to production. A working level of\nproficiency is expected in many of these core tools across the industry.\nAlthough the technology world moves quickly, the categories of these tools\nchanges less often so learning how to use at least one of each type will help\ntransfer to others in the future.`),mdx(\"p\",null,`Each of these deserve their own dedicated guide and require significant time\ninvestment to truly be called an expert but working level proficiency can be\nachieved in relatively shorter time. Start off gradually with a basic awareness\nof what these tools are and learn them as you need them. A brief overview of\nwhat tools to look into is given below.`),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Operating system and shell\"))),mdx(\"p\",null,`Production servers overwhelming run Linux due to its stability, security and\nbeing free and open source software (FOSS). Many other projects and developer\ntools work best or only work on Unix-like operating systems. Therefore, my\nrecommendation is to use Linux or macOS for your developer machine, or Linux on\nWindows through\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://learn.microsoft.com/en-us/windows/wsl/about\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"Windows Subsystem for Linux (WSL)\"),`\nwhile developing. `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://ubuntu.com/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"Ubuntu\"),` is a popular Linux distribution\nto start with. Exceptions exist for platform specific development such as\nWindows for the C# ecosystem with .NET and Visual Studio and macOS for the Apple\necosystem with Swift.`),mdx(\"p\",null,`To interact with your operating system you will spend a lot of time using the\nterminal with a shell such as `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://www.gnu.org/software/bash/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"Bash\"),` which\nis the default in many Linux distributions including Ubuntu. On your local\ndevelopment machine you will also have access to a user interface for example\nfor the file system, Git and Docker. However you will commonly need to work on\nremote servers via SSH to debug production applications or as a cloud\ndevelopment workspace. Comfort with using Linux and the terminal to perform your\neveryday tasks will make it easier to transition to working with remote servers.`),mdx(\"p\",null,\"Here is a list of command line programs I frequently use:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"File system navigation - \",mdx(\"inlineCode\",{parentName:\"li\"},\"ls\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"cd\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"pwd\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"tree\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"mkdir\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"rm\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"touch\")),mdx(\"li\",{parentName:\"ul\"},\"File system search - \",mdx(\"inlineCode\",{parentName:\"li\"},\"grep\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"find\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"which\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"env\")),mdx(\"li\",{parentName:\"ul\"},\"File and string manipulation - \",mdx(\"inlineCode\",{parentName:\"li\"},\"vim\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"cat\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"echo\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"head\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"tail\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"cut\"),`,\n`,mdx(\"inlineCode\",{parentName:\"li\"},\"sed\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"jq\")),mdx(\"li\",{parentName:\"ul\"},\"File compression - \",mdx(\"inlineCode\",{parentName:\"li\"},\"zip\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"unzip\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"tar\")),mdx(\"li\",{parentName:\"ul\"},\"Network requests - \",mdx(\"inlineCode\",{parentName:\"li\"},\"curl\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"wget\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"openssl\")),mdx(\"li\",{parentName:\"ul\"},\"Resource management - \",mdx(\"inlineCode\",{parentName:\"li\"},\"top\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"ps\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"kill\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"free\")),mdx(\"li\",{parentName:\"ul\"},\"Other - \",mdx(\"inlineCode\",{parentName:\"li\"},\"tmux\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"ssh\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"git\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"docker\"))),mdx(\"p\",null,`It is convention to store shell and program user settings in dotfiles in the\nuser home directory for example `,mdx(\"inlineCode\",{parentName:\"p\"},\"~/.bashrc\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"~/.gitconfig\"),`. Eventually you\nmay version these in your own `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://dotfiles.github.io/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"dotfiles repository\"),`\nto make it easier to bootstrap any new development machine or remote cloud\nworkspace with your preferences.`),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Integrated developer environment (IDE)\"))),mdx(\"p\",null,`To write, run, test and debug code an integrated developer environment (IDE) is\nused. While this can technically be done solely in the terminal with a program\nlike `,mdx(\"inlineCode\",{parentName:\"p\"},\"vim\"),` with considerable customisation there's often a more popular choice\nfor the specific language or target device.`),mdx(\"p\",null,`For a lightweight easy to use code editor\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://code.visualstudio.com/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"VSCode\"),` is a good option with strong built in\nsupport for TypeScript and its rich ecosystem of extensions allows it to be\ntransformed into an IDE for any language.`),mdx(\"p\",null,`For a more heavyweight feature rich out of the box IDE consider Visual Studio,\nIntelliJ IDEA, PyCharm, GoLand depending on your language.`),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Version control system (VCS)\"))),mdx(\"p\",null,`Source code must be managed well to handle the complexity of developers\ncollaborating on features and bug fixes asynchronously in their own independent\nenvironments. The most popular version control system (VCS) for this is\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://git-scm.com/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"Git\"),` and the most popular remote repository hosting\nservice is `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"GitHub\"),\".\"),mdx(\"p\",null,`Given the universal adoption of Git, IDEs provide deep integration with it which\ncan be helpful but you should be familiar with operating with `,mdx(\"inlineCode\",{parentName:\"p\"},\"git\"),` from the\nterminal as well.`),mdx(\"p\",null,\"Common workflows with Git include:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Creating and cloning a Git repository - \",mdx(\"inlineCode\",{parentName:\"li\"},\"git init\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"git clone\")),mdx(\"li\",{parentName:\"ul\"},\"Committing and pushing a Git repository - \",mdx(\"inlineCode\",{parentName:\"li\"},\"git add\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"git status\"),`,\n`,mdx(\"inlineCode\",{parentName:\"li\"},\"git commit\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"git push\")),mdx(\"li\",{parentName:\"ul\"},\"Setting up Git branches and fetching new upstream changes - \",mdx(\"inlineCode\",{parentName:\"li\"},\"git branch\"),`,\n`,mdx(\"inlineCode\",{parentName:\"li\"},\"git checkout\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"git fetch\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"git pull\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"git remote\")),mdx(\"li\",{parentName:\"ul\"},`Merging and rebasing Git branches including resolving merge conflicts -\n`,mdx(\"inlineCode\",{parentName:\"li\"},\"git merge\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"git rebase\")),mdx(\"li\",{parentName:\"ul\"},\"Managing multiple development branches - \",mdx(\"inlineCode\",{parentName:\"li\"},\"git worktree\"))),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Continuous integration and deployment (CI/CD)\"))),mdx(\"p\",null,`For a software project to keep high velocity it's critical that the main branch\nalways builds successfully and is deployed often for rapid iteration. This\ninvolves tasks such as installing dependencies, compiling, linting, testing,\nbuilding and publishing artifacts against pushed commits and tags. Rather than\nhave a developer manually perform these steps this is automated in a continuous\nintegration and deployment (CI/CD) pipeline.`),mdx(\"p\",null,`There exist multiple providers but\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://docs.github.com/en/actions\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"GitHub Actions\"),` is an obvious choice to\nstart with if your Git repositories are already hosted on GitHub.`),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Build system\"))),mdx(\"p\",null,`During both CI/CD and local development the dependency graph between project\ntasks becomes difficult to manage manually. For example, if a line of source\ncode is changed in a subproject you need to know in order to rerun tests the\nrelevant source code and its dependencies must be recompiled otherwise the test\nresults will be stale. We could just recompile all code in the project but that\nbecomes slow and inefficient for large monorepo style projects. Furthermore, if\nthe inputs haven't changed the results can be cached and reused across\nindependent CI runs saving lots of time.`),mdx(\"p\",null,`The need for efficient and correct builds leads to using a build system.\nExamples include Bazel, Gradle, Ant, Make and Turbo. Each language ecosystem may\nhave build systems specifically designed for them. `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://bazel.build/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"Bazel\"),`\nis a solid language and platform agnostic build system to choose.`),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Cloud\"))),mdx(\"p\",null,`Production applications need to run on servers somewhere. Historically that\nmeant renting dedicated machines in data centres but today the default option is\nusing virtual machines (VMs) in the cloud. This enables low cost commodity\nhardware resources to be shared securely between multiple customers and scaled\nelastically depending on demand.`),mdx(\"p\",null,`Possibilities include managing the VMs on the cloud and deploying to the VMs\nyourself as Infrastructure as a Service (IaaS) or providing application code in\nthe form of containers or otherwise to be managed and run on the cloud directly\nas Platform as a Service (PaaS).`),mdx(\"p\",null,\"The main players are \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://aws.amazon.com/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"Amazon Web Services\"),` (AWS),\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://cloud.google.com/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"Google Cloud Platform\"),` (GCP) and\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://azure.microsoft.com/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"Microsoft Azure\"),`. Each platform offers some quota\nof services under a free tier to get started and it's best to start off with\njust one of them to benefit from the whole integrated platform.`),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Containers\"))),mdx(\"p\",null,`Running software in different environments is hard. Even between developers on a\nsingle team with the same model hardware it's frequent to hear the saying \"it\nworks on my machine!\". Containers exist to solve this problem by packaging an\napplication together with its dependencies to run in a reproducible environment.\nThe overhead is less compared to VMs due to the host operating system kernel\nbeing shared across containers.`),mdx(\"p\",null,`There exist standard specifications for containers by the Open Container\nInitiative (OCI). `,mdx(\"a\",e({parentName:\"p\"},{href:\"https://www.docker.com/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"Docker\"),` heavily contributed to the\nOCI and is the default platform for developers to build OCI compliant images and\nrun containers. To run containers in production an orchestration system such as\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://kubernetes.io/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"Kubernetes\"),` (k8s) is used which under the hood can use\ndifferent container runtimes including `,mdx(\"inlineCode\",{parentName:\"p\"},\"containerd\"),` which was originally split\nout from Docker during attempts to make it more modular.`),mdx(\"p\",null,\"Common workflows with the Docker CLI include:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Building an image from a Dockerfile - \",mdx(\"inlineCode\",{parentName:\"li\"},\"docker build\")),mdx(\"li\",{parentName:\"ul\"},\"Running a container from an image in a registry - \",mdx(\"inlineCode\",{parentName:\"li\"},\"docker run\")),mdx(\"li\",{parentName:\"ul\"},\"Attaching to a running container and inspecting logs - \",mdx(\"inlineCode\",{parentName:\"li\"},\"docker ps\"),`,\n`,mdx(\"inlineCode\",{parentName:\"li\"},\"docker exec\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"docker logs\")),mdx(\"li\",{parentName:\"ul\"},\"Stopping and removing containers - \",mdx(\"inlineCode\",{parentName:\"li\"},\"docker stop\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"docker rm\")),mdx(\"li\",{parentName:\"ul\"},\"Managing locally pulled images - \",mdx(\"inlineCode\",{parentName:\"li\"},\"docker pull\"),\", \",mdx(\"inlineCode\",{parentName:\"li\"},\"docker images\"))),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Design\"))),mdx(\"p\",null,`Design tools can be used to mock user interfaces and information architecture of\napplications and a company may have Product Designers for this purpose. They are\nstill valuable for developers to create architecture diagrams as an important\nstep in the software development lifecycle to plan implementation and gather\nfeedback from teams.`),mdx(\"p\",null,mdx(\"a\",e({parentName:\"p\"},{href:\"https://figma.com/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"Figma\"),` is the best full featured collaborative design\nplatform today. The images in this blog were all created in Figma! Other\nlightweight options to experiment with are Excalidraw and draw.io.`),mdx(\"h2\",null,\"Projects\"),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"blog/how-to-learn-dev/projects.png\",alt:\"projects\"}))),mdx(\"p\",null,`Software development is creative! The joy is in the huge variety of projects\nthat can be worked on.`),mdx(\"p\",null,`Find your passion. If you enjoy algorithms you might continue studying theory\nand join competitive programming contests. If you enjoy user facing applications\nyou might try to build and deploy an app to help others. If you enjoy AI/ML you\nmight try to train your own model for a bespoke task.`),mdx(\"p\",null,`This is highly personal and dependent on your own interest but some ideas if\nyou're struggling:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Script to automate task you find yourself repeating\"),mdx(\"li\",{parentName:\"ul\"},`Command line interface (CLI) to interact with an external service from the\nterminal`),mdx(\"li\",{parentName:\"ul\"},\"Web/mobile/desktop application\"),mdx(\"li\",{parentName:\"ul\"},\"Personal website/blog\"),mdx(\"li\",{parentName:\"ul\"},\"Large language models (LLMs) applied to a new area of interest\"),mdx(\"li\",{parentName:\"ul\"},\"Simple database implementation from scratch\"),mdx(\"li\",{parentName:\"ul\"},\"Small bug fixes in open source projects\")),mdx(\"p\",null,`Don't worry about how large or small a project is, the biggest challenge is\ngetting started.`),mdx(\"p\",null,`As well as exploring your own projects, I recommend spending lots and lots of\ntime reading other codebases. This will help as inspiration for your own\nprojects, teach you new programming tricks and open your mind to various styles\nof writing code. You will eventually form your own opinions and code style after\nyears of reading and writing code. Try to start from a user facing string in a\npiece of software you use and reverse engineer how the system works from\nsearching the source code. Doing this improves your debugging skills and\ndecreases the time it will take you to onboard onto a new codebase in the\nfuture.`),mdx(\"p\",null,`Use this as an opportunity to put into practice the developer tools you've\nlearned at a small enough scale that you can see the whole picture. At larger\ncompanies there may be abstractions on top of tools or internally developed\nsubstitutes for them to streamline processes and enforce consistency which\nincrease developer productivity but also make it easy to skip understanding the\nfundamentals behind them. For example, set up your own CI/CD pipeline for your\ncode repository from scratch which will save you time in the long run and teach\nyourself valuable skills.`),mdx(\"p\",null,\"Below are some extra thoughts and resources:\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Contributing to open source\"))),mdx(\"p\",null,`Giving back to the developer community can be one of the most rewarding ways to\nspend time and a lot of the code we rely on depends on the hard work of the\npeople working on open source projects. A word of warning though that,\nespecially as a beginner, it is not realistic to contribute to the largest open\nsource projects without a considerable time investment on all sides. In fact,\nsome maintainers may take the stance that no external contributions are accepted\nto avoid the potential discouraging experience for everyone.`),mdx(\"p\",null,`If going down this route, it's best to focus on small less controversial changes\nsuch as documentation and small bug fixes while demonstrating good communication\nand commitment which may grow into a longer term relationship of trust. Look for\nsmaller open source projects which may have more bandwidth and a shortage of\ncontributors. A personal motivation behind a contribution may also improve your\nchances of keeping morale up for example if it would allow you to remove a\nworkaround in your own application code.`),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Clean Code\")),`\n(`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://www.oreilly.com/library/view/clean-code-a/9780136083238/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"https://www.oreilly.com/library/view/clean-code-a/9780136083238/\"),\")\"),mdx(\"p\",null,`A well liked book for teaching guidelines to follow when writing code including\ndon't repeat yourself (DRY) and keep it simple stupid (KISS). Worth reading\nearly on to form intuition on what good or bad code may look like and why. As\nwith most advice, it's important to be open minded and not treat it as rules set\nin stone that can never be broken - exceptions always exist.`),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"Design Patterns\")),`\n(`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://www.oreilly.com/library/view/design-patterns-elements/0201633612/\",target:\"_blank\",rel:\"nofollow noopener noreferrer\"}),\"https://www.oreilly.com/library/view/design-patterns-elements/0201633612/\"),\")\"),mdx(\"p\",null,`Also known as the \"Gang of Four\" design patterns book which prescribes and gives\nnames to object oriented programming solutions for repeatedly seen software\nproblems. This book requires some experience in writing object oriented\nprogramming, however it is likely that while reading any established codebase\nyou will spot at least one of the design patterns inside. Similar to how\nalgorithms share knowledge of building blocks of code, design patterns share\nknowledge of building blocks of objects.`),mdx(\"h2\",null,\"Conclusion\"),mdx(\"p\",null,`The best advice I can give is to stay curious and keep writing code. We all look\nback at early code we have written and laugh or feel embarrassed but writing\ncode that serves a purpose to people and enjoying the journey along the way is\nwhat matters. At a certain point the pieces will start to click together and\nyou'll look behind at the mountain you've climbed and look forward to the next\none ahead.`),mdx(\"p\",null,`I hope that this has been useful as it would have been for me at the start of my\ncareer! If you have any questions you are welcome to reach out.`))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"how-to-learn-dev"},"buildId":"z-bIchNx-oJygQTEe6m7g","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>